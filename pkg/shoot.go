package pkg

import (
	gardencorev1alpha1 "github.com/gardener/gardener/pkg/apis/core/v1alpha1"
	"k8s.io/apimachinery/pkg/util/intstr"

	gardenv1beta1 "github.com/gardener/gardener/pkg/apis/garden/v1beta1"
	garden "github.com/gardener/gardener/pkg/client/garden/clientset/versioned"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// CreateShoot create a shoot for a project
func CreateShoot(client *garden.Clientset, project *gardenv1beta1.Project, secretBinding *gardenv1beta1.SecretBinding, purpose, k8sVersion string) (*gardenv1beta1.Shoot, error) {
	project, err := client.GardenV1beta1().Projects().Get(project.GetName(), metav1.GetOptions{})
	if err != nil {
		return nil, err
	}
	var createdBy string
	if project.Spec.CreatedBy != nil {
		createdBy = project.Spec.CreatedBy.Name
	}
	allowPrivilegedContainers := true
	autoUpdate := false
	beginMaintenance := "230000+0000"
	endMaintenance := "000000+0000"

	maxSurge := intstr.FromInt(1)
	maxUnavailable := intstr.FromInt(1)

	nodesCIDR := gardencorev1alpha1.CIDR("")
	podsCIDR := gardencorev1alpha1.CIDR("")
	servicesCIDR := gardencorev1alpha1.CIDR("")
	shoot := &gardenv1beta1.Shoot{
		ObjectMeta: metav1.ObjectMeta{
			Name: project.Name,
			Annotations: map[string]string{
				"garden.sapcloud.io/createdBy": createdBy,
				"garden.sapcloud.io/purpose":   purpose,
				"cluster.metal-pod.io/project": project.Name,
			},
			Namespace: *project.Spec.Namespace,
		},
		Spec: gardenv1beta1.ShootSpec{
			Addons: &gardenv1beta1.Addons{
				KubernetesDashboard: &gardenv1beta1.KubernetesDashboard{
					Addon: gardenv1beta1.Addon{Enabled: false},
				},
				NginxIngress: &gardenv1beta1.NginxIngress{
					Addon: gardenv1beta1.Addon{Enabled: true},
				},
			},
			Cloud: gardenv1beta1.Cloud{
				Profile: "metal",
				Region:  "fra",
				SecretBindingRef: corev1.LocalObjectReference{
					Name: secretBinding.Name,
				},
				Metal: &gardenv1beta1.MetalCloud{
					LoadBalancerProvider: "metallb",
					MachineImage: &gardenv1beta1.MachineImage{
						Name:    "metal",
						Version: "ubuntu-19.04",
					},
					FirewallImage: "firewall-1",
					FirewallSize:  "c1-xlarge-x86",
					Networks: gardenv1beta1.MetalNetworks{
						K8SNetworks: gardencorev1alpha1.K8SNetworks{
							Nodes:    &nodesCIDR,
							Pods:     &podsCIDR,
							Services: &servicesCIDR,
						},
						Additional: []string{"internet-fra"},
					},
					Workers: []gardenv1beta1.MetalWorker{
						gardenv1beta1.MetalWorker{
							Worker: gardenv1beta1.Worker{
								Name:           "c1-xlarge-x86",
								MachineType:    "c1-xlarge-x86",
								AutoScalerMin:  1,
								AutoScalerMax:  1,
								MaxSurge:       &maxSurge,
								MaxUnavailable: &maxUnavailable,
							},
							VolumeType: "storage_1",
							VolumeSize: "200Gi",
						},
					},
					Zones: []string{"nbg-w8101"},
				},
			},
			Kubernetes: gardenv1beta1.Kubernetes{
				AllowPrivilegedContainers: &allowPrivilegedContainers,
				Version:                   k8sVersion,
			},
			Maintenance: &gardenv1beta1.Maintenance{
				AutoUpdate: &gardenv1beta1.MaintenanceAutoUpdate{
					KubernetesVersion: autoUpdate,
					// MachineImageVersion: &autoUpdate,
				},
				TimeWindow: &gardenv1beta1.MaintenanceTimeWindow{
					Begin: beginMaintenance,
					End:   endMaintenance,
				},
			},
		},
	}

	return client.GardenV1beta1().Shoots(*project.Spec.Namespace).Create(shoot)
	// 	apiVersion: garden.sapcloud.io/v1beta1
	// kind: Shoot
	// metadata:
	//     annotations:
	//         garden.sapcloud.io/createdBy: heinz.schenk@f-i-ts.de
	//         garden.sapcloud.io/purpose: production # will prevent a default hibernation schedule...
	//         cluster.metal-pod.io/project: ice-deployment
	//     name: <auto-generated-by-gardener> # maximum 10 characters
	//     namespace: garden-<cluster-id>
	// spec:
	//     addons:
	//         kubernetes-dashboard:
	//             enabled: false
	//         nginx-ingress:
	//             enabled: false # would deploy one load balancer type service, which ip address we do not want to give away just like that... it's also unclear from which network it should grab an ip
	//     cloud:
	//         metal:
	//             tenant: hlb
	//             firewallImage: firewall-1
	//             firewallSize: c1-xlarge-x86
	//             loadbalancer:
	//                 enabled: true
	//                 networks:
	//                 - count: 1 # one for vpn-shoot is required from us, it is important that vpn connection gets established otherwise the cluster is not "healthy" because api server can't reach the workers
	//                   name: internet-nbg-w8101
	//                 loadBalancerProvider: metallb
	//             machineImage:
	//                 name: metal
	//                 version: ubuntu-19.04
	//             networks:
	//                 additional:
	//                 - <external-networks>
	//                 nodes: 10.250.0.0/16
	//                 pods: 10.242.0.0/16
	//                 services: 10.243.0.0/16
	//             workers:
	//             -   autoScalerMax: 1
	//                 autoScalerMin: 1
	//                 machineType: c1-xlarge-x86
	//                 maxSurge: 1
	//                 maxUnavailable: 0
	//                 name: worker-x1a35
	//                 volumeSize: 50Gi # not interesting for us as it is bound to the machine type
	//                 volumeType: storage_1 # not interesting for us as it is bound to the machine type
	//             zones:
	//             - nbg-w8101
	//             profile: metal
	//             region: nbg
	//         secretBindingRef:
	//             name: garden-<cluster-id>
	//             seed: garden-<cluster-id>
	//     kubernetes:
	//         allowPrivilegedContainers: true
	//         version: 1.14.3
	//     maintenance:
	//         autoUpdate:
	//         kubernetesVersion: true
	//         timeWindow:
	//         begin: 230000+0000
	//         end: 000000+0000

}
